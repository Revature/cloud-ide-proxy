env TOKEN_EXPIRY_TIME;
env BACKEND_URL;
env PING_INTERVAL;
env JWT_SECRET;

# Explicitly set paths
pid /usr/local/openresty/nginx/logs/nginx.pid;
error_log /usr/local/openresty/nginx/logs/error.log;

events {
    worker_connections 1024;
}

http {

    lua_shared_dict cache 10m;  # Shared memory space for caching

    # Define temp paths
    client_body_temp_path /usr/local/openresty/nginx/client_body_temp;
    proxy_temp_path /usr/local/openresty/nginx/proxy_temp;
    fastcgi_temp_path /usr/local/openresty/nginx/fastcgi_temp;
    uwsgi_temp_path /usr/local/openresty/nginx/uwsgi_temp;
    scgi_temp_path /usr/local/openresty/nginx/scgi_temp;
    
    # Set access log path
    access_log /usr/local/openresty/nginx/logs/access.log;

    lua_package_path '/usr/local/openresty/lualib/?.lua;;';
    
    init_by_lua_block {

            cjson = require "cjson"
            jwt = require "resty.jwt"
            jwt_secret = os.getenv("JWT_SECRET")
            if not jwt_secret or #jwt_secret ~= 32 then
                ngx.log(ngx.ERR, "Invalid JWT_SECRET: Must be exactly 32 bytes")
                jwt_secret = nil  -- Prevent usage if invalid
            end

        }

    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    server {
        listen 8020;

        # Proxy websockets with an encrypted IP
        location ~ ^/dest/(?<jwt_val>[A-Za-z0-9._-]+)(/.*)?$ {
            
            set_by_lua_block $target_ip {
                local jwt_val = ngx.var.jwt_val
                local cached_jwt_ip = ngx.shared.cache:get(jwt_val)
                if cached_jwt_ip then
                    return cached_jwt_ip
                end
                
                -- Decode JWT back to its values
                local jwt_obj = jwt:verify(jwt_secret, jwt_val)
            
                if jwt_obj.verified then
                    local decoded_json = cjson.encode(jwt_obj.payload)
                    ngx.log(ngx.INFO, "Complete payload: ", decoded_json)
                    ngx.shared.cache:set(jwt_val, jwt_obj.payload.runner_ip)
                    return jwt_obj.payload.runner_ip
                else
                    ngx.log(ngx.WARN, "JWT verification failed: ", jwt_obj.reason)
                    return "NoAccess"
                end
            }

            if ($target_ip = "NoAccess") {
                return 403;  # Forbidden
            }
            
            rewrite ^/dest/[^/]+(/.*)?$ $1 break;
            proxy_pass http://$target_ip:3000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # Proxy requests from /api/ to localhost:8000/api/
        location ~ ^/api/(.*)$ {
            proxy_pass http://172.20.0.1:8000/$1;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
